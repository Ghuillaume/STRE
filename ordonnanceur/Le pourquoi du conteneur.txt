
---
Pourquoi je ne suis pas d'accord, par Guillaume Charon (1992-xxxx)
---

La structure n'a pas été validée il y a deux semaines, puisqu'on n'en a jamais discuté. On aurait du réfléchir sur papier, keskonékons. C'est juste qu'on est tous partis un peu dans notre sens et on a continué comme ça. Ou alors j'étais pas là et les absents ont tort, mais ce serait bête de ne proposer aucune amélioration.

Bref, si j'ai soulevé le problème existentiel de la classe conteneur, c'est parce qu'elle ne sert à rien. Il suffit de regarder notre code : on ne se sert de la classe conteneur que pour accéder au vecteur qui est contenu dedans. Je vois pas trop l'intérêt. Ca obscurcit les sources plus qu'autre chose : on a HUIT fichiers rien que pour stocker nos tâches en mémoire, c'est assez énorme.
Si, y a les fonctions ppcm et getHyperPeriode. Sauf que ce sont des méthodes à déplacer, elles n'ont rien à faire ici.

Si on repose le problème en partant de zéro, de quoi a-t-on besoin ? De deux vecteurs, l'un contenant les tâches périodiques, l'autre contenant les tâches apériodiques. Ces deux vecteurs seront créés dans le Parseur, on est tous d'accord là-dessus, que ce soit par l'intermédiaire d'un conteneur ou pas. Et ils seront utilisés dans la classe Ordonnanceur.
Je propose donc 2 solution :
	1- Le Parseur contient les deux vecteurs, et met des getters à disposition de l'ordonnanceur
	2- Le Parseur créer les deux vecteurs et les renvoie (sous forme de vecteur de vecteur ?). Ils sont passés en paramètre à l'ordonnanceur qui va les enregistrer
	
Jérôme n'est pas d'accord avec la première solution car selon lui, ce n'est pas au rôle du Parseur de stocker les vecteurs. Mais ce sera la même chose avec les Conteneurs : le Parseur va lire le fichier, puis stocker un Conteneur, qui va stocker un vecteur. Ou alors j'aimerai bien savoir comment faire autrement ???


Étant donné que c'est moi qui ai soulevé le problème, je veux bien avoir la responsabilité de changer le code si on tombe d'accord la dessus.

A la limite je suis d'accord sur un point, c'est que ça permet de ne pas vider le vecteur. L'intérêt est plutot limité je trouve, puisqu'il faudrait s'appeler Durand pour vider le vecteur. Par contre, la solution la plus adaptée aurait été d'étendre la classe vecteur et de surcharger la méthode pop_back pour qu'elle ne fasse rien.


Par contre je viens de changer d'avis. Je laisse ma prose parce que ça fait chier d'efface le fruit de mon dur labeur.
Ok pour un Conteneur, mais seulement UN qui contiendra les deux vecteurs. Et je pense que le mieux est de le retourner à la classe Ordonnanceur à la fin de sa construction.



+--------------------------------------------+
|De l'intérêt d'avoir un conteneur de tâches.|
+--------------------------------------------+

	Dans ce fichier, je vais essayer de répondre de manière la plus exhaustive possible sur l'intérêt d'un conteneur de tâches pour stocker des vecteurs de pointeurs de tâches.


1) La nécessité d'une interface
-------------------------------

	Premièrement, il est intéressant de limiter la visibilité de ce genre d'attribut pour empêcher de faire n'importe quoi avec. Sans interface, on peut utiliser absolument toutes les méthodes de vecteurs sur ceux-ci même si elles n'ont aucune légitimité comme le pull ou la destruction d'index.
	De plus, il est plus facile d'utiliser des méthodes spécifiques à une classe conteneur puisque celle-ci permet de tester la validité des tâches avant leur insertion, et ce de manière automatique.


2) La destruction dynamique et automatique d'objets
---------------------------------------------------

	Une des grande fonctionnalité du C++, c'est la possibilité de gérer finement la mémoire en l'allouant et en  la libérant quand on le souhaite. Cependant, il est possible lors de la destruction d'objets d'entraîner aisément la destruction des objets attributs qui composent la classe. L'intérêt de ceci, c'est l'automatisation de la destruction des vecteurs ainsi que des tâches qui les composent juste en rajoutant une ligne dans le destructeur.
	Évidemment, il est possible de les détruire à partir de l'ordonnanceur mais n'est-ce pas plus simple de n'utiliser qu'une seule ligne "delete conteneur;" au lieu de plusieurs ?
	

3) La passage simplifié de paramètres dans les méthodes
-------------------------------------------------------

	Le principe du conteneur, c'est un peu comme les objets-contexte dans les applis professionnelles : on le passe aux classes qui en ont besoin c'est bien plus simple pour transférer de l'information que de multiplier les pointeurs en paramètre.
	Il suffit de créer dans le main ce conteneur puis d'envoyer un pointeur à chaque classe qui en aura besoin. Rien de bien compliqué et ça facilite la vie de tout le monde.


4) L'amélioration de la modularité du projet 
--------------------------------------------

	(Cette partie fait le lien avec la matière "Concepts et outils de developpement")
	
	Dans le cas où l'application doit évoluer, il est plus simple de séparer les composants pour faciliter la lecture de code, son amélioration et la correction de bugs. 
	Dans les bonnes pratique de l'écriture de code, il vaut mieux éviter les classes fourre-tout où on stocke des attributs et méthodes très différents, surtout si celles-ci ont une taille de plusieurs centaines de lignes.


5) Une structure validée depuis 2 semaines
------------------------------------------

	Je veux bien croire que tout d'un coup l'architecture du programme ne convienne plus mais dans ce cas-là, on discute avec tout le groupe avant de remettre en question des décisions prises il y a plus de 2 semaines.
	Un changement soudain dans la structure de l'appli, ça impacte tout le monde. Si jamais un tel changement doit avoir lieu, tout le programme doit être modifié directement, pas seulement la partie qui arrange la personne qui fait le changement.
	De plus, avant tout changement, il serait bon d'informer les gens qui s'occupent des parties impactées que ça va probablement les empêcher de continuer et que toute une partie du code est à revoir.
	
	
Conclusion
----------

	Si jamais j'ai tort, n'hésitez surtout pas à me le démontrer, c'est comme ça qu'on progresse. Pour le moment, je suis plutôt d'accord avec moi-même et ce qui est écrit plus haut.
	Je finirai juste par dire que reprendre tout le code à propos des conditions d'ordonnançabilité pour l'adapter à ce qui a été nouvellement modifié me brise un peu les noix donc j'attendrai qu'on soit bien au clair sur notre manière de procéder avant de m'y attaquer.

	JP.
